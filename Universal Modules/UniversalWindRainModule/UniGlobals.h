#ifndef _UNI_GLOBALS_H
#define _UNI_GLOBALS_H
//----------------------------------------------------------------------------------------------------------------
#define UNUSED(expr) do { (void)(expr); } while (0)
//----------------------------------------------------------------------------------------------------------------
//Структура передаваемая мастеру и обратно
//----------------------------------------------------------------------------------------------------------------
enum {RS485FromMaster = 1, RS485FromSlave = 2};
enum 
{
  RS485ControllerStatePacket = 1, 
  RS485SensorDataPacket = 2, 
  RS485WindowsPositionPacket = 3,
  RS485RequestCommandsPacket = 4,
  RS485CommandsToExecuteReceipt = 5,
  RS485SensorDataForRemoteDisplay = 6,
  RS485SettingsForRemoteDisplay = 7,
  RS485WindRainData = 8, // запрос данных по дождю, скорости, направлению ветра
  RS485SunControllerData = 9, // пакет с данными контроллера солнечной установки
};
//----------------------------------------------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct
{
  uint32_t WindowsState; // состояние каналов окон, 4 байта = 32 бита = 16 окон)
  uint16_t WaterChannelsState; // состояние каналов полива, 2 байта, (16 каналов)
  byte LightChannelsState; // состояние каналов досветки, 1 байт (8 каналов)
  byte PinsState[16]; // состояние пинов, 16 байт, 128 пинов
  
} ControllerState; // состояние контроллера
#pragma pack(pop)
//----------------------------------------------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct
{
  byte header1;
  byte header2;

  byte direction; // направление: 1 - от меги, 2 - от слейва
  byte type; // тип: 1 - пакет исполнительного модуля, 2 - пакет модуля с датчиками

  byte data[sizeof(ControllerState)]; // N байт данных, для исполнительного модуля в этих данных содержится состояние контроллера
  // для модуля с датчиками: первый байт - тип датчика, 2 байт - его индекс в системе. В обратку модуль с датчиками должен заполнить показания (4 байта следом за индексом 
  // датчика в системе и отправить пакет назад, выставив direction и type.

  byte tail1;
  byte tail2;
  byte crc8;
  
} RS485Packet; // пакет, гоняющийся по RS-485 туда/сюда (30 байт)
#pragma pack(pop)
//----------------------------------------------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct
{
  uint8_t windDirection;
  uint32_t windSpeed;
  bool hasRain;
  uint8_t reserved[17]; // добитие до 23 байт

} WindRainDataPacket;
#pragma pack(pop)
//----------------------------------------------------------------------------------------------------------------
typedef enum
{
  cpUnknown,  // нет привязки
  cpEast,   // восток
  cpSouth,  // юг
  cpWest,   // запад
  cpNorth   // север
  
} CompassPoints; // стороны света
//--------------------------------------------------------------------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct
{
  byte packet_type; // тип пакета
  byte packet_subtype; // подтип пакета
  byte config; // конфигурация
  byte controller_id; // ID контроллера, к которому привязан модуль
  byte rf_id; // идентификатор RF-канала модуля
  
} UniScratchpadHead; // голова скратчпада, общая для всех типов модулей
#pragma pack(pop)
//-------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct
{
  UniScratchpadHead head; // голова
  byte data[24]; // сырые данные
  byte crc8; // контрольная сумма
  
} UniRawScratchpad; // "сырой" скратчпад, байты данных могут меняться в зависимости от типа модуля
#pragma pack(pop)
//-------------------------------------------------------------------------------------------------------------------------------------------------------
typedef enum
{
  uniSensorsClient = 1, // packet_type == 1
  uniNextionClient = 2, // packet_type == 2
  uniExecutionClient = 3, // packet_type == 3
  uniWindRainClient = 4, // packet_type == 4
  uniSunControllerClient = 5, // packet_type == 5
  
} UniClientType; // тип клиента
//-------------------------------------------------------------------------------------------------------------------------------------------------------
#endif
